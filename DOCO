/*
 * Title:	DOCO
 * Copyright:	(C) 2003 Trevor van Bremen
 * Author:	Trevor van Bremen
 * Created:	01Dec2003
 * Description:
 *	This is just my little list of things to do, things I did etc.
 * Version:
 *	$Id: DOCO,v 1.2 2003/12/22 04:43:15 trev_vb Exp $
 * Modification History:
 *	$Log: DOCO,v $
 *	Revision 1.2  2003/12/22 04:43:15  trev_vb
 *	TvB 21Dec2003 Added in a cvs header section
 *	
 */
TODO:1	Transaction processing

TODO:2	Deal with ISVARLEN files

TODO:3	Virtual filesystem

TODO:4	Look into making the system into a shared memory based ISAM engine

TODO:5	Look into the TREE buffering further
	Since this area has the potential to have a *LOT* of memory allocated,
	I believe it's worthwhile offering the end-user far more options for
	configuring how much is actually buffered.
	Suggestions:
	-	Limit buffering per file to 'n' bytes
	-	Limit buffering per index within a file to 'n' bytes
	-	Limit buffering per file to 'n' keys
	-	Limit buffering per index within a file to 'n' keys
	-	The existing method (Limit buffering to 'n' tree levels)
	As soon as *ANY* limit is exceeded, the vVBExit() routine should begin
	de-allocation.  Naturally, the current leaf-to-root structure within
	any given TREE *MUST* be retained, but everything else is viable for
	an 'extreme prejudice' de-allocation.

TODO:8	Merge the various cNode0, cNode1 static char variables to lower the
	runtime RAM requirements.  This affects the following modules:
	-	isbuild.c
	-	isopen.c
	-	vbDataIO.c
	-	vbIndexIO.c
	-	vbKeys.c
	-	vbLocking.c

TODO:9	Look into limiting the namespace pollution as much as possible to avoid
	any potential conflict with end-user processes.  Possibly by merging
	all the various modules into one 'super-module'.  This would lead to
	a potential downside in that any end-user program would end up linking
	in the ENTIRE library rather than just the modules it needs.  However,
	the current structure of modules means that this latter fact is already
	largely true anyway.  (Possible exception being the isbuild.c module).

NOTE	The in-memory buffering of the TREE data when in CISAM compatible mode
	(32-bit mode), is somewhat useless given that there is no 'stamp' on the
	node to determine whether it is stale.  However, this buffering REALLY
	comes into play when in 64-bit mode since the timestamp can mean the
	library can completely ignore de-compressing a node that's not changed.
	Heck, I could even 'engineer' the node routines to *FORCE* there to be
	additional space for a QUADSIZE (trans stamp) value in the node when it
	gets written back to disk?

DONE	Still needs more work on vbIndexIO.c to deal with NodeFree / DataFree

DONE	Currently, data row locking will THRASH the fcntl due to the islock() /
	isunlock () lock that's applied to 0-0 of the data file.  Thus any file
	open in ISAUTOLOCK mode will require TWO locks per row!

DONE	Possibly look into being able to read / write / lock genuine C-ISAM data
	The iNodeLoad and iNodeSave functions in vbKeys.c would bear the brunt
	of these changes.  Additionally, I should endeavor to make the locking
	strategy C-ISAM compatible too.
	Thus, the affected files would be:
	-	isinternal.h
	-	vbKeys.c
	-	isopen.c
	-	isbuild.c
	-	vbIndexIO.c
	-	vbLocking.c

DONE	Possibly look at changing data file I/O to use nodes and, when possible,
	avoid re-reading a node that's not changed.  Use a simple LRU algorithm!

DONE	Change isbuild.c and isopen.c to use the sDictNode structure

DONE	Deal with ISEXCLLOCK mode in isopen()

DONE	Logically, I need to combine isread() amd isstart() into a single module

DONE	Handle the ISDESC flag on a keypart type in iVBPartCompare ()

DONE	Technically, it should be feasible for ALL of the VBISAM files open in
	one process to *SHARE* a common row buffer and / or common index node
	buffer(s).  This will require changes to isinternal.h (pcRowBuffer) and
	also isopen.c

DONE	Need to add in locking / exclusivity et al into:
		isdelete.c
		isopen.c
		isread.c
		isrewrite.c
		isstart.c
		istrans.c
		iswrite.c

vbKeys.c
DONE	RAM utilization is somewhat EXCESSIVE... Limit this?
DONE	A nice addition would be to make use of the QUADSIZE variable in each
	B+ Tree node within the iNodeLoad () function to alleviate some unneeded
	reloading.  More importantly, the iNodeLoad will require an extra arg to
	specify if loading the node is MANDATORY or ELECTIVE
DONE	This value would have to be set in the iNodeSave () function.

================================================================================
Where each function is located
==============================
isHelper.c
----------
TODO	iscluster (int iHandle, struct keydesc *psKeyDescription);
	iserase (char *pcFilename);
	isflush (int iHandle);
	islock (int iHandle);
	isrelease (int iHandle);
	isrename (char *pcOldFilename, char *pcNewFilename);
	issetunique (int iHandle, off_t tUniqueID);
	isuniqueid (int iHandle, off_t *llUniqueID);
	isunlock (int iHandle);
	ldchar (char *pcSource, int iLength, char *pcDestination);
	stchar (char *pcSource, char *pcDestination, int iLength);
	ldint (char *pcLocation);
	stint (int iSource, char *pcDestination);
	long	ldlong (char *pcLocation);
	stlong (long lSource, char *pcDestination);
	off_t	ldquad (char *pcLocation);
	stquad (off_t tSource, char *pcDestination);
	double	ldfloat (char *pcLocation);
	stfloat (double dSource, char *pcDestination);
	double	ldfltnull (char *pcLocation, int *piNullflag);
	stfltnull (double dSource, char *pcDestination, int iNullflag);
	lddbl (char *pcLocation);
	stdbl (double dSource, char *pcDestination);
	lddblnull (char *pcLocation, int *piNullflag);
	stdblnull (double dSource, char *pcDestination, int iNullflag);

isbuild.c
---------
	isbuild (char *pcFilename, off_t tRowLength, struct keydesc *psKeyDescription, int iMode);
	isaddindex (int iHandle, struct keydesc *psKeyDescription);
	isdelindex (int iHandle, struct keydesc *psKeyDescription);

isdelete.c
----------
	isdelete (int iHandle, char *pcRow);
	isdelcurr (int iHandle);
	isdelrec (int iHandle, off_t tRowNumber);

isopen.c
--------
	isopen (char *pcFilename, int iMode);
	isindexinfo (int iHandle, struct keydesc *psKeyDescription, int iIndexNumber);
	isclose (int iHandle);
	iscleanup ();

isread.c
--------
	isread (int iHandle, char *pcRow, int iMode);
	isstart (int iHandle, struct keydesc *psKeyDescription, int iLength, char *pcRow, int iMode);

isrewrite.c
-----------
	isrewrite (int iHandle, char *pcRow);
	isrewcurr (int iHandle, char *pcRow);
	isrewrec (int iHandle, off_t tRowNumber, char *pcRow);

istrans.c
---------
TODO	isaudit (int iHandle, char *pcFilename, int iMode);
TODO	isbegin ();
TODO	iscommit ();
TODO	islogclose ();
TODO	islogopen (char *pcLogFilename);
TODO	isrecover ();
TODO	isrollback ();

iswrite.c
---------
	iswrite (int iHandle, char *pcRow);
	iswrcurr (int iHandle, char *pcRow);
